// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: supacrypt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Supacrypt_V1_KeyAlgorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case rsa // = 1
  case ecc // = 2
  case ecdsa // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .rsa
    case 2: self = .ecc
    case 3: self = .ecdsa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .rsa: return 1
    case .ecc: return 2
    case .ecdsa: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_KeyAlgorithm: CaseIterable {
  public static var allCases: [Supacrypt_V1_KeyAlgorithm] = [
    .unspecified,
    .rsa,
    .ecc,
    .ecdsa,
  ]
}

#endif

public enum Supacrypt_V1_RSAKeySize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case size2048 // = 2048
  case size3072 // = 3072
  case size4096 // = 4096
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 2048: self = .size2048
    case 3072: self = .size3072
    case 4096: self = .size4096
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .size2048: return 2048
    case .size3072: return 3072
    case .size4096: return 4096
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_RSAKeySize: CaseIterable {
  public static var allCases: [Supacrypt_V1_RSAKeySize] = [
    .unspecified,
    .size2048,
    .size3072,
    .size4096,
  ]
}

#endif

public enum Supacrypt_V1_ECCCurve: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case p256 // = 1
  case p384 // = 2
  case p521 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .p256
    case 2: self = .p384
    case 3: self = .p521
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .p256: return 1
    case .p384: return 2
    case .p521: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_ECCCurve: CaseIterable {
  public static var allCases: [Supacrypt_V1_ECCCurve] = [
    .unspecified,
    .p256,
    .p384,
    .p521,
  ]
}

#endif

public enum Supacrypt_V1_HashAlgorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case sha256 // = 1
  case sha384 // = 2
  case sha512 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .sha256
    case 2: self = .sha384
    case 3: self = .sha512
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .sha256: return 1
    case .sha384: return 2
    case .sha512: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_HashAlgorithm: CaseIterable {
  public static var allCases: [Supacrypt_V1_HashAlgorithm] = [
    .unspecified,
    .sha256,
    .sha384,
    .sha512,
  ]
}

#endif

public enum Supacrypt_V1_RSAPaddingScheme: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case pkcs1 // = 1
  case pss // = 2
  case oaep // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pkcs1
    case 2: self = .pss
    case 3: self = .oaep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pkcs1: return 1
    case .pss: return 2
    case .oaep: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_RSAPaddingScheme: CaseIterable {
  public static var allCases: [Supacrypt_V1_RSAPaddingScheme] = [
    .unspecified,
    .pkcs1,
    .pss,
    .oaep,
  ]
}

#endif

public enum Supacrypt_V1_ErrorCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case success // = 1
  case invalidRequest // = 2
  case keyNotFound // = 3
  case keyAlreadyExists // = 4
  case unsupportedAlgorithm // = 5
  case invalidSignature // = 6
  case operationNotSupported // = 7
  case authenticationFailed // = 8
  case authorizationFailed // = 9
  case networkError // = 10
  case internalError // = 11
  case keySizeNotSupported // = 12
  case curveNotSupported // = 13
  case hashNotSupported // = 14
  case paddingNotSupported // = 15
  case decryptionFailed // = 16
  case encryptionFailed // = 17
  case azureKvError // = 18
  case pkcs11Error // = 19
  case cspError // = 20
  case kspError // = 21
  case ctkError // = 22
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .invalidRequest
    case 3: self = .keyNotFound
    case 4: self = .keyAlreadyExists
    case 5: self = .unsupportedAlgorithm
    case 6: self = .invalidSignature
    case 7: self = .operationNotSupported
    case 8: self = .authenticationFailed
    case 9: self = .authorizationFailed
    case 10: self = .networkError
    case 11: self = .internalError
    case 12: self = .keySizeNotSupported
    case 13: self = .curveNotSupported
    case 14: self = .hashNotSupported
    case 15: self = .paddingNotSupported
    case 16: self = .decryptionFailed
    case 17: self = .encryptionFailed
    case 18: self = .azureKvError
    case 19: self = .pkcs11Error
    case 20: self = .cspError
    case 21: self = .kspError
    case 22: self = .ctkError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .invalidRequest: return 2
    case .keyNotFound: return 3
    case .keyAlreadyExists: return 4
    case .unsupportedAlgorithm: return 5
    case .invalidSignature: return 6
    case .operationNotSupported: return 7
    case .authenticationFailed: return 8
    case .authorizationFailed: return 9
    case .networkError: return 10
    case .internalError: return 11
    case .keySizeNotSupported: return 12
    case .curveNotSupported: return 13
    case .hashNotSupported: return 14
    case .paddingNotSupported: return 15
    case .decryptionFailed: return 16
    case .encryptionFailed: return 17
    case .azureKvError: return 18
    case .pkcs11Error: return 19
    case .cspError: return 20
    case .kspError: return 21
    case .ctkError: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }
}

#if swift(>=4.2)

extension Supacrypt_V1_ErrorCode: CaseIterable {
  public static var allCases: [Supacrypt_V1_ErrorCode] = [
    .unspecified,
    .success,
    .invalidRequest,
    .keyNotFound,
    .keyAlreadyExists,
    .unsupportedAlgorithm,
    .invalidSignature,
    .operationNotSupported,
    .authenticationFailed,
    .authorizationFailed,
    .networkError,
    .internalError,
    .keySizeNotSupported,
    .curveNotSupported,
    .hashNotSupported,
    .paddingNotSupported,
    .decryptionFailed,
    .encryptionFailed,
    .azureKvError,
    .pkcs11Error,
    .cspError,
    .kspError,
    .ctkError,
  ]
}

#endif

public struct Supacrypt_V1_KeyParameters {
  public var algorithmParams: Supacrypt_V1_KeyParameters.OneOf_AlgorithmParams?

  public var rsaParams: Supacrypt_V1_RSAParameters {
    get {
      if case .rsaParams(let v)? = algorithmParams {return v}
      return Supacrypt_V1_RSAParameters()
    }
    set {algorithmParams = .rsaParams(newValue)}
  }

  public var eccParams: Supacrypt_V1_ECCParameters {
    get {
      if case .eccParams(let v)? = algorithmParams {return v}
      return Supacrypt_V1_ECCParameters()
    }
    set {algorithmParams = .eccParams(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AlgorithmParams: Equatable {
    case rsaParams(Supacrypt_V1_RSAParameters)
    case eccParams(Supacrypt_V1_ECCParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Supacrypt_V1_KeyParameters.OneOf_AlgorithmParams, rhs: Supacrypt_V1_KeyParameters.OneOf_AlgorithmParams) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rsaParams, .rsaParams): return {
        guard case .rsaParams(let l) = lhs, case .rsaParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eccParams, .eccParams): return {
        guard case .eccParams(let l) = lhs, case .eccParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Supacrypt_V1_RSAParameters {
  public var keySize: Supacrypt_V1_RSAKeySize = .unspecified

  public var publicExponent: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Supacrypt_V1_ECCParameters {
  public var curve: Supacrypt_V1_ECCCurve = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// Implementation continues with other message types...
// This is a simplified version focusing on the essential types for CTK implementation